本文是Ulrich Drepper的“每个程序员都应当知道的内存知识”系列的第6部分。本文包括第6节的后半段，涉及对多线程代码的优化。本节的前半段post在该系列的[第5部分](？？)。

# 6.4 多线程优化 #
<p> 遇到多线程时，高速缓存的如下三方面很重要： </p>
并行性（concurrency）
原子性（atomicity）
带宽
<p> 这些方面同样适用于多进程的情况，但由于进程间多是相互独立的，多进程并不容易优化。多进程优化是多线程优化技巧的子集。因此这里我们着重讨论后者。</p>
<p> 并行性在这里指的是一个进程同时运行多个线程时的内存效果。这些线程共用同一地址空间，因而连接到同一内存空间。理想情况下，不同线程使用这一内存空间中的不同区域，从而它们之间的耦合不大（例如共用输入输出）。但如果多个线程要使用同一数据，就需要协调。这时就要考虑原子性。最后，每个处理器的可用内存和处理器间总线带宽是有限的。我们将在下文中分别讨论这紧密相关的三个方面。</p>
## 6.4.1 并行性优化 ##
<p> 我们首先讨论两个要求相反优化方向的问题。一方面，一个多线程应用程序的不同线程会共用一些数据。通常的缓存优化要求把这些数据放在一起，从而减少该应用占用的内存，提高缓存的利用率。</p>
<p> 另一方面，这种做法有一个问题：如果多个线程都可能写入同一个内存地址，那么写入时该缓存线在每个核的L1d缓存中都必须处于“E”（exclusive，排它的）状态。这意味着要发出很多RFO请求，最坏情况下每次写入都需要发出一次RFO。因此一个简单的写入操作就变得非常慢。共用内存需要同步化（可以通过下节所讲的原子操作），尽管这一问题在多个线程独立使用不同内存区域时也存在。</p>
<p> 图6.10: 并行内存线读写overhead </p>
<p> 图6.10展示了这一“不良共用”的后果。测试程序（见9.3节）创建多个线程，并increment同一个内存地址500,000,000次。所测时间为从程序开始到最后一个线程完成的间隔。这些线程都在固定的处理器中执行。测试机器有4个P4处理器。蓝色柱代表的是分配不同缓存线给各个线程的情况。红色柱是不同线程共用同一缓存线的情况。</p>
<p> 蓝色柱（使用独立缓存线）的结果与符合预期：使用更多线程不引入额外时间成本。每个处理器只接触自己L1d中的缓存线，从而没有任何带宽问题，因为所有需要读区的程序和数据都在高速缓存中。图中微量的时间只是系统噪声或者一些预取效应（这些线程使用序列的（sequential）缓存线）。</p> 
<p> 红色柱（共用缓存线时）对应的额外时间消耗在使用2、3、4线程时则达到了390%、734%、1147%。这些数字第一眼看去可能大得令人惊讶，但考虑到所需的缓存交流，这实在是很自然的事情。处理器写入一个缓存线后，该缓存线就要被从缓存中拉出。其他处理器不得不延迟，无法做任何事。处理器数量越多延迟就越久。</p> 
<p> 上述测量说明该情景必须在编程时尽量避免。由于其巨大时间消耗，这一问题常常非常明显。但现代硬件有一个陷阱。图6.11展示了在4核单处理器机器（Intel Core 2 QX 6700）进行的类似测量。尽管该处理器有两个独立的L2高速缓存，测量结果并未展现出扩展性上的问题。共用缓存线会造成一些额外消耗，但并不随核的数量增加而增加。如果使用两个或以上这样的处理器，我们又会重新看到图6.10中的问题。因此，尽管多核处理器越来越普及，很多电脑仍然会使用多个处理器，因此我们需要能正确处理这种情况，比如在真正的SMP电脑上测试代码。</p> 
<p> 一个简单的办法可以“解决”这个问题：将每个变量都加载到每个处理器的高速缓存线上。这就和前面提到的对高速缓存的一般优化原则冲突了。具体来说，应用程序占用的缓存会成倍增加。这一点是无法容忍的。因此我们需要想出更聪明的办法。 </p> 
<p> 真正需要的是分辨在哪些变量在任一时刻都仅被一个线程使用，哪些变量从头到尾只被同一个线程使用，而哪些变量会被争用。每种情形都有几种可能且有效的解决办法。最基本的分类变量的标准是：会不会被写入，写入有多频繁。 </p> 
<p> 从不被写入的变量和只初始化一次的变量基本上相当于常量。由于只有写入操作需要发送RFO请求，我们完全可以让常量在缓存间共用（“S”状态）。因此，处理这些变量不必有复杂的技巧，只需要把它们放在一起就行了。如果程序员正确地标记这些变量为 const，它们会被tool chain从一般变量中区分开并放在.rodata（read-only data，只读数据）或者.data.rel.ro（read-only after relocation，重定位后只读）section中。{Sections, identified by their names are the atomic units containing code and data in an ELF file.} 无需其他特殊操作。如果在一些情况下变量无法被标记为 const，程序员可以指派它们到一个特殊section中。 </p>
<p> 连接器生成最终二进制码时会首先在section后附上从所有输入文件中得到的同一名称；连接器代码接下来为这些section排序。这意味着，通过把这些相当于常量但没有被标记为常量的变量移动到一个特殊section中，程序员可以把这些变量集中起来。它们中没有谁会被经常写入。只要正确地对齐（align）其中第一个变量，就可能保证不出现不良共用。考虑如下代码： </p>
<p> int foo = 1;
  int bar __attribute__((section(".data.ro"))) = 2;
  int baz = 3;
  int xyzzy __attribute__((section(".data.ro"))) = 4; </p>
<p> 编译后，该文件定义了4个变量。变量foo、baz和bar、xyzzy被分别分组。  </p>
